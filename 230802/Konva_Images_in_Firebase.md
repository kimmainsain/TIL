### **문제 상황**

konva로 별자리 커스텀을 하는건 문제가 없다. 그런데 저장 부분에서 문제가 생김. 완성된 별자리를 이미지화해서 저장해야 하는데, 그 URL이 너무 길어서 30000자가 넘은 상황이다. 이를 해결해보자.

### **해결 방안**

1. **이미지 파일로 저장 후 URL 관리**: 캔버스 내용을 이미지 파일로 변환한 후, 그 파일을 서버에 저장하고 그 파일의 URL을 데이터베이스에 저장하는 방법. AWS S3나 Azure Blob Storage 같은 곳을 쓸 수 있겠다.
2. **Blob 데이터로 변환 후 Database 저장**: 캔버스의 데이터를 Blob형식으로 변환하고, 이 Blob데이터를 바이너리 형식으로 데이터베이스에 저장. 하지만, 데이터 크기가 적당해야 하고, 데이터베이스가 바이너리 저장을 지원해야 한다.
3. **데이터 압축**: 이미지 자체를 압축하거나 Data URL을 텍스트 압축 알고리즘을 사용해 압축하면 크기 문제는 해결되겠지만, 복잡하고 시간도 좀 걸릴 수 있다.
4. **외부 스토리지 서비스 이용**: Firebase 같은 외부 서비스를 쓰면 편하게 저장하고 관리할 수 있을 것 같다.

### 백엔드에 URL을 저장해야하는 이유

1. **권한관리** : 사용자별로 어떤 이미지에 액세스할 수 있는지 제어하려면 백엔드에서 권한을 확인하고 적절한 URL을 제공해야함
2. **조직화** : 특정 사용자, 카테고리, 태그 등과 같이 연관된 이미지를 효율적으로 관리하려면 백엔드에서 연관 정보와 함께 URL을 저장해야함
3. **캐싱 및 최적화** : 클라이언트에 제공하기 전에 이미지를 다른 형식으로 변환하거나 최적화하려면 백엔드에서 URL을 관리해야함

# **별자리 커스텀 완성본을 이미지화해서 Firebase에 저장하기**

문제 상황: konva로 별자리 커스텀하는 건 괜찮았는데, 이제 완성본을 이미지로 만들어서 Firebase에 어떻게 저장할지 고민이었다.

### **해결 방법:**

1. **이미지 Data URL 가져오기**

   ```jsx
   jsxCopy code
   const url = stageRef.current.toDataURL();

   ```

   Konva 스테이지를 이미지 Data URL로 바꾼다.

2. **Data URL을 Blob으로 변환하기**
- Firebase의 **`uploadBytesResumable`** 함수가 Blob객체나 바이너리 타입을 필요로 하기 때문이다.
- base64 문자열로 인코딩하면 이미지 파일 형식이 유지되지 않는다. Blob객체로 바꾸면 유지할 수 있다.
- Blob객체는 대용량 바이너리 데이터도 효율적으로 다룰 수 있다.
- 결국, base64 문자열을 실제 파일 업로드나 처리를 위해 원래의 바이너리 형태로 바꿔야 하고, 그래서 Blob 객체를 사용해야 한다.
4. **Blob을 Firebase에 업로드하기**

5. **업로드 상태 관리하고 다운로드 URL 가져오기**

6. **백엔드에 URL 저장하기**
